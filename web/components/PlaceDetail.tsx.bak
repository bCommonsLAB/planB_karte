"use client"

import React, { useState } from 'react'
import { Sheet } from './ui/sheet'
import { Feature } from 'geojson'
import { ExternalLink, Clock, MapPin, Phone, Mail, User, Tag, Info, Edit, Save, X } from 'lucide-react'

// Typ-Erweiterung für globale Hilfsvariablen
declare global {
  interface Window {
    _planBPickerModeActive?: boolean;
    _planBLastSelectedCoordinates?: [number, number];
  }
}

// Ergänze die Interface-Definition, um die _id für MongoDB zu berücksichtigen
interface MongoDBFeature extends Feature {
  _id?: string;
}

interface PlaceDetailProps {
  place: MongoDBFeature | null
  isOpen: boolean
  onClose: () => void
  onUpdate?: (updatedPlace: MongoDBFeature) => void
  onPickLocation?: (callback: (coordinates: [number, number]) => void) => void
}

const PlaceDetail: React.FC<PlaceDetailProps> = ({ place, isOpen, onClose, onUpdate, onPickLocation }) => {
  const [isEditing, setIsEditing] = useState(false)
  const [formData, setFormData] = useState<any>({})
  const [isSaving, setIsSaving] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [saveSuccess, setSaveSuccess] = useState(false)
  const [isPickingLocation, setIsPickingLocation] = useState(false)

  // Wenn sich der ausgewählte Ort ändert, aktualisiere das Formular
  React.useEffect(() => {
    console.log("### PlaceDetail useEffect: Place geändert ###", place?._id);
    console.log("### PlaceDetail DETAILLIERTER PLACE DUMP ###", JSON.stringify(place, null, 2));
    
    if (place && place.properties) {
      console.log("### PlaceDetail: Formular aktualisiert ###");
      
      // Hole die Koordinaten aus dem Place-Objekt oder verwende die global gespeicherten
      let coordinates: [number, number] = [0, 0];
      
      // Prüfe, ob global gespeicherte Koordinaten vorhanden sind (für Race-Condition-Fälle)
      const savedCoordinates = window._planBLastSelectedCoordinates;
      
      if (place.geometry && place.geometry.type === 'Point') {
        // Standard-Fall: Verwende die Koordinaten aus dem Geometrie-Objekt
        coordinates = [place.geometry.coordinates[1], place.geometry.coordinates[0]];
        console.log("### PlaceDetail: Verwende Koordinaten aus Geometrie:", coordinates);
        console.log("### PlaceDetail: Original-Geometrie:", place.geometry.coordinates);
      } 
      else if (savedCoordinates && Array.isArray(savedCoordinates) && savedCoordinates.length === 2) {
        // Fall-Back: Verwende die global gespeicherten Koordinaten
        coordinates = [savedCoordinates[1], savedCoordinates[0]]; // Umwandlung von [lon, lat] zu [lat, lon]
        console.log("### PlaceDetail: Verwende global gespeicherte Koordinaten:", coordinates);
        console.log("### PlaceDetail: Original gespeicherte Koordinaten:", savedCoordinates);
      }
      
      setFormData({
        ...place.properties,
        coordinates: coordinates
      });
      
      console.log("### PlaceDetail: Formular mit Koordinaten gesetzt ###", coordinates);
      
      // Die URL-Aktualisierung bei jedem useEffect-Aufruf entfernen, da sie zu Endlosschleifen führt
      // Stattdessen nur einmalig die ID speichern, wenn sie sich ändert
      console.log("### PlaceDetail: Ort geladen mit ID ###", place._id);
    }
  }, [place])
  
  // Überwache Änderungen an isOpen
  React.useEffect(() => {
    console.log("### PlaceDetail: isOpen geändert ###", isOpen);
  }, [isOpen])

  // Überwachen wir auch Änderungen am formData, um zu sehen, wann sich die Koordinaten ändern
  React.useEffect(() => {
    if (formData.coordinates) {
      console.log("### PlaceDetail: Koordinaten im Formular geändert ###", formData.coordinates);
    }
  }, [formData.coordinates]);
  
  // Notfall-Listener für das forceReopenDialog-Event
  React.useEffect(() => {
    const handleForceReopen = (event: CustomEvent) => {
      console.log("### PlaceDetail: forceReopenDialog Event empfangen ###", event.detail);
      
      // Lokalen Zustand für isPickingLocation zurücksetzen
      if (isPickingLocation) {
        console.log("### PlaceDetail: Setze isPickingLocation zurück ###");
        setIsPickingLocation(false);
      }
      
      // WICHTIG: Globale Variable zurücksetzen, um Race-Conditions zu vermeiden
      window._planBPickerModeActive = false;
      
      // WICHTIG: Sicherstellen, dass der Dialog wieder geöffnet wird
      if (!isOpen) {
        // Wenn möglich, informiere die übergeordnete Komponente
        if (onUpdate && place) {
          console.log("### PlaceDetail: Informiere übergeordnete Komponente, dass der Dialog geöffnet werden soll ###");
          onUpdate(place);
        }
      }
      
      // Verwende die Koordinaten aus dem Event, falls vorhanden
      if (event.detail?.coordinates && Array.isArray(event.detail.coordinates) && event.detail.coordinates.length === 2) {
        console.log("### PlaceDetail: Aktualisiere Formular mit Koordinaten aus Event ###", event.detail.coordinates);
        
        // Die Koordinaten sind im [lon, lat] Format, also wandeln wir sie in [lat, lon] um
        const coordinates: [number, number] = [event.detail.coordinates[1], event.detail.coordinates[0]];
        
        // WICHTIG: Speichere auch global
        window._planBLastSelectedCoordinates = event.detail.coordinates;
        
        // Formular aktualisieren
        setFormData((prev: Record<string, any>) => ({
          ...prev,
          coordinates: coordinates
        }));
      }
    };
    
    // Typumwandlung, da TypeScript nicht weiß, dass CustomEvent verwendet wird
    document.addEventListener('forceReopenDialog', handleForceReopen as EventListener);
    
    return () => {
      document.removeEventListener('forceReopenDialog', handleForceReopen as EventListener);
    };
  }, [isPickingLocation, setFormData, isOpen, place, onUpdate]);

  if (!place) return null

  const properties = place.properties || {}
  const {
    Name,
    Beschreibung,
    Adresse,
    Öffnungszeiten,
    Telefonnummer,
    Email,
    Ansprechperson,
    Kategorie,
    Tags,
    'Webseite(n)': Webseite
  } = properties

  // Bestimme die Farbe basierend auf der Kategorie
  const categoryColors: Record<string, string> = {
    'A': 'bg-red-100 text-red-800 border-red-200',
    'B': 'bg-green-100 text-green-800 border-green-200',
    'C': 'bg-blue-100 text-blue-800 border-blue-200'
  }
  const categoryColor = categoryColors[Kategorie as string] || 'bg-gray-100 text-gray-800 border-gray-200'

  // Handler für Formularänderungen
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target
    setFormData({
      ...formData,
      [name]: value
    })
  }

  // Handler für Koordinatenänderungen mit zusätzlichem Logging
  const handleCoordinateChange = (index: number, value: string) => {
    const newCoordinates = [...formData.coordinates]
    newCoordinates[index] = parseFloat(value) || 0
    
    console.log(`### PlaceDetail: Koordinate an Index ${index} manuell geändert ###`, {
      alt: formData.coordinates,
      neu: newCoordinates
    });
    
    setFormData({
      ...formData,
      coordinates: newCoordinates
    })
  }
  
  // Handler für die Auswahl eines Ortes auf der Karte
  const handlePickLocation = () => {
    console.log("### PlaceDetail handlePickLocation aufgerufen ###");
    
    if (!onPickLocation) {
      setError("Ortsauswahl auf der Karte wird nicht unterstützt.");
      return;
    }
    
    // Ortsauswahl-Modus aktivieren
    console.log("### PlaceDetail: Aktiviere Ortsauswahl-Modus ###");
    setIsPickingLocation(true);
    
    // WICHTIG: Globale Variable für die Ortsauswahl aktivieren
    window._planBPickerModeActive = true;
    
    // Callback-Funktion für die Kartenkomponente, um die ausgewählten Koordinaten zu erhalten
    console.log("### PlaceDetail: Definiere Koordinaten-Callback und übergebe an MapExplorer ###");
    onPickLocation((coordinates: [number, number]) => {
      console.log("### PlaceDetail: KOORDINATEN-CALLBACK WURDE AUFGERUFEN ###", coordinates);
      
      // Koordinaten aktualisieren: [lon, lat] zu [lat, lon] für das Formular umwandeln
      const updatedCoordinates = [coordinates[1], coordinates[0]];
      console.log("### PlaceDetail: Wandle Koordinaten um ###", updatedCoordinates);
      
      // WICHTIG: Globale Variable zurücksetzen
      window._planBPickerModeActive = false;
      
      // Globale Koordinaten speichern
      window._planBLastSelectedCoordinates = coordinates;
      
      setFormData({
        ...formData,
        coordinates: updatedCoordinates
      });
      
      console.log("### PlaceDetail: Formular mit neuen Koordinaten aktualisiert ###", updatedCoordinates);
      
      // Auswahl-Modus beenden
      console.log("### PlaceDetail: Beende Ortsauswahl-Modus ###");
      setIsPickingLocation(false);
      
      console.log("### PlaceDetail: Koordinaten-Callback abgeschlossen ###");
      // Der Dialog wird automatisch wieder geöffnet, da MapExplorer setIsDetailOpen(true) aufruft
    });
    
    console.log("### PlaceDetail: Callback an MapExplorer übergeben, Dialog wird geschlossen ###");
  }

  // Handler zum Speichern der Änderungen
  const handleSave = async () => {
    console.log("### PlaceDetail: handleSave aufgerufen ###");
    console.log("### PlaceDetail: Formular-Daten vor dem Speichern ###", formData);
    
    // KRITISCH: Die aktuellen Koordinaten im Formular sind die einzigen, die wir verwenden sollten
    const currentCoordinates = formData.coordinates;
    
    if (currentCoordinates) {
      console.log("### PlaceDetail: Zu speichernde Koordinaten [lat, lon] ###", currentCoordinates);
      console.log("### PlaceDetail: Umgewandelte Koordinaten [lon, lat] für Geometrie ###", 
        [currentCoordinates[1], currentCoordinates[0]]);
    } else {
      console.warn("### PlaceDetail: KEINE Koordinaten im Formular gefunden! ###");
    }
    
    setIsSaving(true)
    setError(null)
    setSaveSuccess(false)

    try {
      // Erstelle ein aktualisiertes Feature
      const updatedFeature = {
        ...place,
        properties: {
          ...formData,
          // Aktualisiere auch die alten Koordinaten im properties-Objekt, falls sie existieren
          "Koordinate N": currentCoordinates ? currentCoordinates[0] : undefined,
          "Koordinate O": currentCoordinates ? currentCoordinates[1] : undefined,
          // Entferne die Koordinaten aus den Properties
          coordinates: undefined
        },
        geometry: currentCoordinates ? {
          type: 'Point',
          coordinates: [currentCoordinates[1], currentCoordinates[0]] // [lon, lat]
        } : place?.geometry
      }
      
      console.log("### PlaceDetail: Aktualisiertes Feature zum Speichern ###", updatedFeature);
      if (updatedFeature.geometry?.type === 'Point') {
        console.log("### PlaceDetail: Finale Geometrie ###", updatedFeature.geometry);
        console.log("### PlaceDetail: Finale Koordinaten ###", updatedFeature.geometry.coordinates);
      }

      // Versuche, die ID aus verschiedenen möglichen Quellen zu ermitteln
      let placeId = place?._id;
      
      // Wenn keine ID direkt im Feature gefunden wurde, prüfe in den Properties
      if (!placeId && place?.properties && place.properties._id) {
        placeId = place.properties._id;
        console.log("ID aus Properties extrahiert:", placeId);
      }
      
      // Versuche, die ID direkt aus dem API zu holen, falls sie nicht gefunden wurde
      if (!placeId && place?.geometry?.type === 'Point') {
        try {
          const coords = place.geometry.coordinates;
          console.log("Suche nach Ort mit Koordinaten:", coords);
          
          // Hole alle Orte und suche nach passenden Koordinaten
          const response = await fetch('/api/places');
          const data = await response.json();
          
          if (data && data.features && Array.isArray(data.features)) {
            const matchingFeature = data.features.find((f: any) => 
              f.geometry && 
              f.geometry.type === 'Point' && 
              f.geometry.coordinates[0] === coords[0] && 
              f.geometry.coordinates[1] === coords[1]
            );
            
            if (matchingFeature && matchingFeature._id) {
              placeId = matchingFeature._id;
              console.log("ID über Koordinaten-Suche gefunden:", placeId);
            }
          }
        } catch (err) {
          console.error("Fehler bei der Suche nach ID über Koordinaten:", err);
        }
      }
      
      // Zusätzliche Debug-Informationen
      console.log("Place ID zum Speichern:", placeId);
      console.log("Vollständiges Place-Objekt:", place);
      console.log("Place._id:", place?._id);
      console.log("Place.properties:", place?.properties);
      console.log("Place.properties._id:", place?.properties?._id);
      
      if (!placeId) {
        throw new Error('Keine ID für diesen Ort gefunden. Bitte Seite neu laden und erneut versuchen.');
      }

      // Sende die Aktualisierung an den korrekten API-Endpunkt mit der ID
      console.log(`Sende Update an /api/places/${placeId}`);
      const response = await fetch(`/api/places/${placeId}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updatedFeature)
      })

      if (!response.ok) {
        throw new Error(`Fehler beim Speichern: ${response.status}`);
      }
      
      // Versuche die Antwort zu lesen, um die tatsächlich gespeicherten Daten zu sehen
      try {
        const savedData = await response.json();
        console.log("### PlaceDetail: Vom Server bestätigte Daten ###", savedData);
        if (savedData.geometry?.type === 'Point') {
          console.log("### PlaceDetail: Vom Server bestätigte Koordinaten ###", savedData.geometry.coordinates);
        }
      } catch (e) {
        console.log("### PlaceDetail: Keine JSON-Antwort vom Server ###");
      }

      // Bearbeitungsmodus beenden
      setIsEditing(false)
      
      // Erfolgsindikator setzen statt alert
      setSaveSuccess(true)
      
      // Nach 3 Sekunden den Erfolgsindikator zurücksetzen
      setTimeout(() => {
        setSaveSuccess(false)
      }, 3000)
      
      // WICHTIG: Synchronisiere das lokale formData mit den aktuellen Koordinaten,
      // damit sie nicht versehentlich zurückgesetzt werden
      setFormData((prevFormData: Record<string, any>) => ({
        ...prevFormData,
        coordinates: currentCoordinates
      }));
      
      // Aktualisierungsfunktion aufrufen, wenn vorhanden, um die Daten im übergeordneten Element zu aktualisieren
      const updatedPlaceWithId: MongoDBFeature = {
        ...place,
        _id: placeId,
        properties: {
          ...formData,
          // Aktualisiere auch die alten Koordinaten im properties-Objekt, falls sie existieren
          "Koordinate N": currentCoordinates ? currentCoordinates[0] : undefined,
          "Koordinate O": currentCoordinates ? currentCoordinates[1] : undefined,
          // Entferne die Koordinaten aus den Properties
          coordinates: undefined
        },
        geometry: currentCoordinates ? {
          type: 'Point' as const,
          coordinates: [currentCoordinates[1], currentCoordinates[0]] // [lon, lat]
        } : place?.geometry
      };
      
      console.log("### PlaceDetail: Finales updatedPlaceWithId für onUpdate ###", updatedPlaceWithId);
      if (updatedPlaceWithId.geometry?.type === 'Point') {
        console.log("### PlaceDetail: Finale Koordinaten für onUpdate ###", updatedPlaceWithId.geometry.coordinates);
      }
      
      if (onUpdate) {
        console.log("### PlaceDetail: Rufe onUpdate mit aktualisierten Daten auf ###", updatedPlaceWithId);
        onUpdate(updatedPlaceWithId);
        
        // Trigger ein benutzerdefiniertes Event, um alle Komponenten über die Änderung zu informieren
        const refreshEvent = new CustomEvent('planBMapRefreshMarkers', {
          detail: { updatedFeature: updatedPlaceWithId }
        });
        document.dispatchEvent(refreshEvent);
      }
    } catch (err) {
      console.error('Fehler beim Speichern der Änderungen:', err)
      setError(err instanceof Error ? err.message : 'Unbekannter Fehler beim Speichern')
    } finally {
      setIsSaving(false)
    }
  }

  // Handler zum Aktivieren des Bearbeitungsmodus
  const handleEdit = async () => {
    console.log("### PlaceDetail: Aktiviere Bearbeitungsmodus ###");
    console.log("### PlaceDetail: Aktueller place vor Server-Anfrage ###", place);
    
    try {
      // Hole die neuesten Daten direkt vom Server für diesen Ort
      if (place && place._id) {
        console.log(`### PlaceDetail: Lade neueste Daten für Ort ${place._id} vom Server ###`);
        
        const response = await fetch(`/api/places/${place._id}`);
        
        if (response.ok) {
          const freshPlace = await response.json();
          console.log("### PlaceDetail: Neueste Daten vom Server erhalten ###", freshPlace);
          console.log("### PlaceDetail: Server-Geometrie ###", 
            freshPlace.geometry?.type === 'Point' ? 
              freshPlace.geometry.coordinates : 
              'Keine Point-Geometrie'
          );
          
          // Verwende die neuesten Daten für das Formular
          if (freshPlace && freshPlace.properties) {
            // WICHTIG: Um das Problem mit springenden Koordinaten zu beheben,
            // behalten wir die aktuellen Koordinaten bei und übernehmen nur die anderen Daten
            const currentCoordinates = formData.coordinates || 
              (freshPlace.geometry?.type === 'Point' ? 
                [freshPlace.geometry.coordinates[1], freshPlace.geometry.coordinates[0]] : // [lat, lon]
                [0, 0]);
            
            console.log("### PlaceDetail: Beibehalten der aktuellen Koordinaten ###", currentCoordinates);
            
            const updatedFormData = {
              ...freshPlace.properties,
              // Verwende die aktuellen Koordinaten statt der vom Server
              coordinates: currentCoordinates
            };
            
            console.log("### PlaceDetail: Aktualisiere Formular mit neuesten Daten ###", updatedFormData);
            console.log("### PlaceDetail: Beibehaltene Koordinaten für Editor ###", updatedFormData.coordinates);
            setFormData(updatedFormData);
            
            // Aktualisiere auch das Hintergrund-Objekt mit den beibehaltenen Koordinaten
            const updatedPlace = {
              ...freshPlace,
              geometry: {
                type: 'Point',
                coordinates: [currentCoordinates[1], currentCoordinates[0]] // [lon, lat] für Geometrie
              }
            };
            
            // Informiere den übergeordneten MapExplorer über die neuesten Daten mit beibehaltenen Koordinaten
            if (onUpdate) {
              console.log("### PlaceDetail: Aktualisiere übergeordneten MapExplorer mit beibehaltenen Koordinaten ###");
              onUpdate(updatedPlace);
            }
          }
        } else {
          console.warn(`### PlaceDetail: Fehler beim Laden der neuesten Daten: ${response.status} ###`);
          console.log("### PlaceDetail: Verwende bestehende Daten für Bearbeitungsmodus ###", formData);
        }
      }
    } catch (error) {
      console.error("### PlaceDetail: Fehler beim Laden der neuesten Daten ###", error);
      console.log("### PlaceDetail: Verwende bestehende Daten aufgrund eines Fehlers ###", formData);
    }
    
    // Aktiviere den Bearbeitungsmodus
    setIsEditing(true);
  };

  return (
    <Sheet isOpen={isOpen && !isPickingLocation} onClose={onClose}>
      <div className="flex flex-col h-full max-h-[90vh]">
        {/* Hinweis, wenn im Ortsauswahlmodus */}
        {isPickingLocation && (
          <div className="fixed top-4 right-4 z-50 bg-blue-600 text-white px-4 py-2 rounded-md shadow-lg">
            Klicke auf die Karte, um den Ort auszuwählen
          </div>
        )}

        {/* Header mit Kategorie aber ohne Buttons */}
        <div className="border-b pb-4">
          <div className="flex items-center justify-between">
            {isEditing ? (
              <input
                type="text"
                name="Name"
                value={formData.Name || ''}
                onChange={handleChange}
                className="text-2xl font-bold text-gray-900 border-b border-gray-300 focus:border-blue-500 focus:outline-none w-full"
                placeholder="Name des Ortes"
              />
            ) : (
              <h2 className="text-2xl font-bold text-gray-900">{Name || 'Unbekannter Ort'}</h2>
            )}
            
            <div className="flex items-center gap-2">
              {!isEditing && saveSuccess && (
                <span className="text-sm text-green-600 animate-fade-in-out">
                  ✓ Gespeichert
                </span>
              )}
              
              {isEditing ? (
                <select
                  name="Kategorie"
                  value={formData.Kategorie || ''}
                  onChange={handleChange}
                  className="px-2 py-1 rounded-full text-xs font-medium bg-white border border-gray-300"
                >
                  <option value="">Keine Kategorie</option>
                  <option value="A">Kategorie A</option>
                  <option value="B">Kategorie B</option>
                  <option value="C">Kategorie C</option>
                </select>
              ) : Kategorie ? (
                <span className={`px-2.5 py-0.5 rounded-full text-xs font-medium ${categoryColor}`}>
                  Kategorie {Kategorie}
                </span>
              ) : null}
            </div>
          </div>
        </div>

        {/* Fehlermeldung */}
        {error && (
          <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-md mt-4">
            {error}
          </div>
        )}

        {/* Inhalt mit Scrollbereich */}
        <div className="flex-1 overflow-y-auto py-4">
          {isEditing ? (
            /* Bearbeitungsformular */
            <div className="space-y-4">
              {/* Beschreibung */}
              <div className="space-y-2">
                <label className="block text-sm font-medium text-gray-700">Beschreibung</label>
                <textarea
                  name="Beschreibung"
                  value={formData.Beschreibung || ''}
                  onChange={handleChange}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                  rows={4}
                  placeholder="Beschreibung des Ortes"
                />
              </div>

              {/* Adresse */}
              <div>
                <label className="block text-sm font-medium text-gray-700">Adresse</label>
                <input
                  type="text"
                  name="Adresse"
                  value={formData.Adresse || ''}
                  onChange={handleChange}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                  placeholder="Straße, Hausnummer, PLZ, Ort"
                />
              </div>

              {/* Öffnungszeiten */}
              <div>
                <label className="block text-sm font-medium text-gray-700">Öffnungszeiten</label>
                <textarea
                  name="Öffnungszeiten"
                  value={formData.Öffnungszeiten || ''}
                  onChange={handleChange}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                  rows={2}
                  placeholder="Montag - Freitag: 9-17 Uhr"
                />
              </div>

              {/* Telefonnummer */}
              <div>
                <label className="block text-sm font-medium text-gray-700">Telefonnummer</label>
                <input
                  type="text"
                  name="Telefonnummer"
                  value={formData.Telefonnummer || ''}
                  onChange={handleChange}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                  placeholder="+43 123 456789"
                />
              </div>

              {/* Email */}
              <div>
                <label className="block text-sm font-medium text-gray-700">E-Mail</label>
                <input
                  type="email"
                  name="Email"
                  value={formData.Email || ''}
                  onChange={handleChange}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                  placeholder="info@beispiel.de"
                />
              </div>

              {/* Ansprechperson */}
              <div>
                <label className="block text-sm font-medium text-gray-700">Ansprechperson</label>
                <input
                  type="text"
                  name="Ansprechperson"
                  value={formData.Ansprechperson || ''}
                  onChange={handleChange}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                  placeholder="Max Mustermann"
                />
              </div>

              {/* Webseite */}
              <div>
                <label className="block text-sm font-medium text-gray-700">Webseite</label>
                <input
                  type="text"
                  name="Webseite(n)"
                  value={formData['Webseite(n)'] || ''}
                  onChange={handleChange}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                  placeholder="https://www.beispiel.de"
                />
              </div>

              {/* Tags */}
              <div>
                <label className="block text-sm font-medium text-gray-700">Tags (ein Tag pro Zeile)</label>
                <textarea
                  name="Tags"
                  value={formData.Tags || ''}
                  onChange={handleChange}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                  rows={3}
                  placeholder="Tag 1&#10;Tag 2&#10;Tag 3"
                />
              </div>

              {/* Koordinaten */}
              <div className="space-y-2">
                <div className="flex justify-between items-center">
                  <label className="block text-sm font-medium text-gray-700">Koordinaten</label>
                  <button
                    type="button"
                    onClick={handlePickLocation}
                    disabled={!onPickLocation || isPickingLocation}
                    className={`